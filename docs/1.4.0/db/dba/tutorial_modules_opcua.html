<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<title>RMVL: 工业自动化通信协议 OPC UA</title>
<link href="../../rmvl-logo-small.png" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<script type="text/javascript" src="/docs/version.js"></script>
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../rmvl-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RMVL
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
   <div id="projectbrief">Robotic Manipulation and Vision Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','搜索',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/da0/tutorials.html">RMVL 使用教程</a></li><li class="navelem"><a class="el" href="../../d6/d6e/tutorial_table_of_content_modules.html">主要模块使用教程</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">工业自动化通信协议 OPC UA</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>目录</h3>
<ul>
  <li class="level1">
    <a href="#autotoc_md253">1. 简介</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md254">1.1 OPC UA 是什么</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md255">1.2 地址空间</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#opcua_server_client">2. 服务器/客户端</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md256">2.1 初始化</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md257">2.2 变量</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md258">2.3 方法</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md259">2.4 对象</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md260">2.5 视图</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md261">2.6 监视</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#opcua_pub_sub">3. 发布/订阅</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md262">3.1 无代理 Pub/Sub</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md263">3.2 有代理 Pub/Sub</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md264">4. 使用技巧</a>
    <ul>
      <li class="level2">
        <a href="#opcua_parameters">4.1 参数加载</a>
      </li>
      <li class="level2">
        <a href="#opcua_nodeset_compiler">4.2 从 XML 配置 OPC UA</a>
        <ul>
          <li class="level3">
            <a href="#autotoc_md265">4.2.1 安装 UaModeler</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md266">4.2.2 可视化配置 OPC UA 信息模型</a>
          </li>
          <li class="level3">
            <a href="#autotoc_md267">4.2.3 生成 *.c/*.h 文件</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md268">4.3 不占有所有权的服务器视图</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md270">5. 引用</a>
  </li>
</ul>
</div>
<div class="textblock"><p>OPC UA 和 open62541 库简介</p>
<p><a class="anchor" id="md__2home_2zhaoxi_2_xE6_xA1_x8C_xE9_x9D_xA2_2Vision_2cv-rmvl_2rmvl_2doc_2tutorials_2modules_2tools_2opcua"></a></p>
<dl class="section author"><dt>作者</dt><dd>赵曦 </dd></dl>
<dl class="section date"><dt>日期</dt><dd>2023/11/24 </dd></dl>
<dl class="section version"><dt>版本</dt><dd>2.0 </dd></dl>
<p><b>上一篇教程：</b><a class="el" href="../../d3/da4/tutorial_modules_serial.html">串口通信模块</a> ↑<br  />
 <b>下一篇教程：</b><a class="el" href="../../df/d2c/tutorial_modules_camera.html">相机设备</a> ↓<br  />
</p>
<hr  />
<p>相关模块： <a class="el" href="../../d3/da8/group__opcua.html">基于 open62541 的 OPC UA 二次开发库</a></p>
<h1><a class="anchor" id="autotoc_md253"></a>
1. 简介</h1>
<h2><a class="anchor" id="autotoc_md254"></a>
1.1 OPC UA 是什么</h2>
<p><a href="https://opcfoundation.org/about/opc-technologies/opc-ua/">OPC UA</a>（全称为 Open Platform Communications Unified Architecture）是一种用于工业和物联网（IoT）应用的开放通信协议和架构。它提供了一种统一的框架，用于在不同设备和系统之间实现数据传输、通信和集成。</p>
<p>OPC UA 的设计目标是建立一种通用的、独立于厂商和平台的通信标准，以实现互操作性和集成性。它提供了一套标准的服务和功能，使不同类型的设备和系统能够相互通信和交换数据，其特点包括：</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">特点   </th><th class="markdownTableHeadCenter">介绍    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">兼容性   </td><td class="markdownTableBodyCenter">OPC UA 不依赖于特定的硬件、操作系统或网络协议，可以在不同的平台上运行，并与其他通信标准集成    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">安全性   </td><td class="markdownTableBodyCenter">OPC UA 提供了强大的安全机制，包括身份验证、加密和访问控制，以确保数据和通信的机密性和完整性    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">可扩展   </td><td class="markdownTableBodyCenter">OPC UA 支持灵活的数据模型和信息建模，可以适应不同应用领域和需求的变化    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">信息建模   </td><td class="markdownTableBodyCenter">OPC UA 使用统一的信息模型，将数据和功能以标准化的方式表示和描述，使不同系统之间的数据交换更加简化和一致    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">可靠性   </td><td class="markdownTableBodyCenter">OPC UA 提供了可靠的通信机制，包括消息确认、重试和错误处理，以确保数据的可靠传输   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md255"></a>
1.2 地址空间</h2>
<p>在 OPC UA 中，所有的数据都被组织成一个地址空间，地址空间中的每一个元素都被称为一个节点。每个节点都有一个唯一的节点号，在 <a class="el" href="../../d3/da8/group__opcua.html">基于 open62541 的 OPC UA 二次开发库</a> 中表示为 <a class="el" href="../../dd/dfe/structrm_1_1NodeId.html" title="OPC UA 节点 ID">rm::NodeId</a> 。</p>
<center></center><center><div class="image">
<object type="image/svg+xml" data="../../opcua.svg" style="pointer-events: none;"></object>
<div class="caption">
图 1-1 OPC UA 地址空间模型</div></div>
    </center><center></center><ol type="1">
<li>对象类型节点 <a class="el" href="../../d4/d40/classrm_1_1ObjectType.html" title="OPC UA 对象类型">rm::ObjectType</a> ：提供对象的定义，即对象的抽象，与类相当，且子类可以继承父类的特征，方便模型的扩充。该节点包括对象的各种数据类型，数据的语义，以及控制方式。OPC UA 命名空间 <code>0</code> 中规定了多个基础的对象类型节点。如使用最广的 BaseObjectType（在 RMVL 中表示为 <code><a class="el" href="../../d3/da8/group__opcua.html#ga939cde15e0534f0e800805640f2d5e5a" title="对象类型节点：BaseObjectType 节点 ID">rm::nodeBaseObjectType</a></code>），所有对象类型节点都需要继承该节点再进行扩充。在对具体设备建模的过程中，应该将设备组成的各部分分解为不同的对象分别建模，再用引用节点将各部分按照实际设备中的关系相关联，从而得到完整设备的对象类型节点。</li>
<li>对象节点 <a class="el" href="../../d8/d9b/classrm_1_1Object.html" title="OPC UA 对象">rm::Object</a> ：将对象类型实例化即可得到对象节点，该节点是设备在数字空间的映射。所有对设备数据的访问都能在该模型中访问到对应的数据节点。所有对 设备的控制都转换为方法节点的触发。设备产生的消息在节点对象中将触发对应的事件。</li>
<li>引用类型节点 <b>ReferenceType</b> ：引用类型描述了引用的语义，而引用用于定义引用两端的节点之间的关系。最常用的引用类型如 Organizes（在 RMVL 中表示为 <code><a class="el" href="../../d3/da8/group__opcua.html#gae1a98aea0a35c74f3088d96b746d19fd" title="引用类型节点：Organizes 节点 ID">rm::nodeOrganizes</a></code>），表示节点之间的层级关系，如同文件夹与文件夹内的文件，数据层级复杂的设备，需要通过多种引用类型对设备信息节点之间的关系进行描述。</li>
<li>数据类型节点 <a class="el" href="../../df/d6b/classrm_1_1DataType.html" title="OPC UA 数据类型">rm::DataType</a> ：数据类型节点描述了变量节点中变量的数据类型。在 OPC UA 信息模型在命名空间 <code>0</code> 中定义了多种内置的数据类型，包括整型、浮点型、 字符串等多个类型，能对变量的数据进行准确的描述。也可以自定义数据类型，比如描述二维坐标的 <code>2DPoint</code> 等类型，获得更符合数据本身的描述。<dl class="section note"><dt>注解</dt><dd>注意：此类节点并不能提供具体的数据构成，只是提供了数据类型的一个描述，因此 RMVL 中的 <a class="el" href="../../d3/da8/group__opcua.html">基于 open62541 的 OPC UA 二次开发库</a> 仅提供内置数据类型。若计划提供数据的构成，比如包含的数据长度等信息，请使用变量类型节点 <a class="el" href="../../d9/de2/classrm_1_1VariableType.html" title="OPC UA 变量类型">rm::VariableType</a> 。</dd></dl>
</li>
<li>变量类型节点 <a class="el" href="../../d9/de2/classrm_1_1VariableType.html" title="OPC UA 变量类型">rm::VariableType</a> ：该节点提供了对变量节点的定义，是设备中各种数据的抽象。常用引用中的 HasTypeDefinition 引用节点连接数据类型节点，对数据类型进行描述（在 RMVL 中表示为 <code><a class="el" href="../../d3/da8/group__opcua.html#gae20fd2e26487e56b43960879380938ce" title="引用类型节点：HasTypeDefinition 节点 ID">rm::nodeHasTypeDefinition</a></code>）。用 HasProperty 引用节点对数据的语义进行描述（在 RMVL 中表示为 <code><a class="el" href="../../d3/da8/group__opcua.html#ga13d561ce57b92cc7c11de2ed77c5e925" title="引用类型节点：HasProperty 节点 ID">rm::nodeHasProperty</a></code>）。也可以使用自定义的数据类型节点对变量的数据进行描述，具有灵活性。</li>
<li>变量节点 <a class="el" href="../../df/db8/classrm_1_1Variable.html" title="OPC UA 变量">rm::Variable</a> ：该节点是变量类型节点的实例，也是使用的最多的节点。客户端访问设备数据有以下 3 种方式。 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">访问方式   </th><th class="markdownTableHeadCenter">介绍   </th><th class="markdownTableHeadCenter">备注    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">直接读写   </td><td class="markdownTableBodyCenter">将设备多模态数据写入对应的变量节点，然后客户端读取对应节点内保存的数值   </td><td class="markdownTableBodyCenter">如果客户端要获取设备最新的值，需要一直手动去触发对设备数据源的读取请求    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">值回调   </td><td class="markdownTableBodyCenter">客户端发起 <b>IO</b> 请求后，服务器在 <b>读取前</b> 和 <b>写入后</b> 分别调用对应的回调函数   </td><td class="markdownTableBodyCenter">可以利用此功能在需要访问数据的时候才让服务器更新数据    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">数据源变量节点   </td><td class="markdownTableBodyCenter">客户端的读取请求直接重定向到设备的数据源中，即客户端直接从数据源获取数据，变量节点不存储数据   </td><td class="markdownTableBodyCenter">缩减了数据先写入变量节点再进行读取的过程，但多个客户端连接访问同一数据时会增大服务器与设备之间的传输负载   </td></tr>
</table>
</li>
<li>方法节点 <a class="el" href="../../d2/d23/structrm_1_1Method.html" title="OPC UA 方法">rm::Method</a> ：方法节点是对设备控制方法在数字模型中的映射。方法节点可以通过服务器或客户端进行调用，然后将会对设备的控制器发送指令，使得设备执行对应的操作。常见的方法节点有：触发视觉采集、电机反转、设备初始化等。</li>
<li>视图节点 <a class="el" href="../../d2/de9/classrm_1_1View.html" title="OPC UA 视图">rm::View</a> ：视图节点可将地址空间中感兴趣的节点提取出来，作为一个子集，视图节点作为该子集的入口，方便客户端浏览。</li>
</ol>
<h1><a class="anchor" id="opcua_server_client"></a>
2. 服务器/客户端</h1>
<p>基于服务器/客户端的方式是 OPC UA 最基本的一种通信方式，上文的地址空间在服务器/客户端通信的过程中完全展现出来。下面列举一些 opcua 模块中常用的服务器与客户端的成员方法。</p>
<h2><a class="anchor" id="autotoc_md256"></a>
2.1 初始化</h2>
<p><b>服务器</b></p>
<div class="fragment"><div class="line"><span class="comment">// server.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../df/d0a/server_8hpp.html">rmvl/opcua/server.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// 创建 OPC UA 服务器，端口为 4840</span></div>
<div class="line">    <a class="code hl_class" href="../../d4/d06/classrm_1_1Server.html">rm::Server</a> srv(4840);</div>
<div class="line">    <span class="comment">// 服务器运行</span></div>
<div class="line">    srv.start();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* other code */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 线程阻塞，直到调用了 srv.stop()，线程才会继续执行。</span></div>
<div class="line">    srv.join();</div>
<div class="line">}</div>
<div class="ttc" id="aclassrm_1_1Server_html"><div class="ttname"><a href="../../d4/d06/classrm_1_1Server.html">rm::Server</a></div><div class="ttdoc">OPC UA 服务器</div><div class="ttdef"><b>定义</b> server.hpp:101</div></div>
<div class="ttc" id="aserver_8hpp_html"><div class="ttname"><a href="../../df/d0a/server_8hpp.html">server.hpp</a></div><div class="ttdoc">OPC UA 服务器</div></div>
</div><!-- fragment --><p><b>客户端</b></p>
<div class="fragment"><div class="line"><span class="comment">// client.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;rmvl/opcua/client&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// 创建 OPC UA 客户端，连接到 127.0.0.1:4840</span></div>
<div class="line">    <a class="code hl_class" href="../../da/d78/classrm_1_1Client.html">rm::Client</a> cli(<span class="stringliteral">&quot;opc.tcp://127.0.0.1:4840&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* other code */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassrm_1_1Client_html"><div class="ttname"><a href="../../da/d78/classrm_1_1Client.html">rm::Client</a></div><div class="ttdoc">OPC UA 客户端</div><div class="ttdef"><b>定义</b> client.hpp:82</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md257"></a>
2.2 变量</h2>
<p>在上文介绍了变量的 3 种访问方式，这里使用最简单的直接读写的方式。首先在服务器中添加变量节点。</p>
<div class="fragment"><div class="line"><span class="comment">// server.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../df/d0a/server_8hpp.html">rmvl/opcua/server.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="../../d4/d06/classrm_1_1Server.html">rm::Server</a> srv(4840);</div>
<div class="line">    srv.start();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 定义 double 型变量，如果要强制使用 3.14 定义 float 型变量，</span></div>
<div class="line">    <span class="comment">// 可以使用 rm::Variable num = float(3.14);</span></div>
<div class="line">    <a class="code hl_class" href="../../df/db8/classrm_1_1Variable.html">rm::Variable</a> num = 3.14;</div>
<div class="line">    <span class="comment">// 浏览名 BrowseName</span></div>
<div class="line">    num.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#a3d20725d0f1a56474ff7bf90f57e7c8d">browse_name</a> = <span class="stringliteral">&quot;number&quot;</span>;</div>
<div class="line">    <span class="comment">// 显示名 DisplayName</span></div>
<div class="line">    num.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ad3099ea3e54575de460b272a1c496203">display_name</a> = <span class="stringliteral">&quot;Number&quot;</span>;</div>
<div class="line">    <span class="comment">// 描述</span></div>
<div class="line">    num.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ae2192d1434ef12e7db2be77b8d616899">description</a> = <span class="stringliteral">&quot;数字&quot;</span>;</div>
<div class="line">    <span class="comment">// 添加到服务器的默认位置（默认被添加至 ObjectsFolder 下）</span></div>
<div class="line">    srv.addVariableNode(num);</div>
<div class="line"> </div>
<div class="line">    srv.join();</div>
<div class="line">}</div>
<div class="ttc" id="aclassrm_1_1Variable_html"><div class="ttname"><a href="../../df/db8/classrm_1_1Variable.html">rm::Variable</a></div><div class="ttdoc">OPC UA 变量</div><div class="ttdef"><b>定义</b> variable.hpp:119</div></div>
<div class="ttc" id="aclassrm_1_1Variable_html_a3d20725d0f1a56474ff7bf90f57e7c8d"><div class="ttname"><a href="../../df/db8/classrm_1_1Variable.html#a3d20725d0f1a56474ff7bf90f57e7c8d">rm::Variable::browse_name</a></div><div class="ttdeci">std::string browse_name</div><div class="ttdoc">浏览名称 BrowseName</div><div class="ttdef"><b>定义</b> variable.hpp:131</div></div>
<div class="ttc" id="aclassrm_1_1Variable_html_ad3099ea3e54575de460b272a1c496203"><div class="ttname"><a href="../../df/db8/classrm_1_1Variable.html#ad3099ea3e54575de460b272a1c496203">rm::Variable::display_name</a></div><div class="ttdeci">std::string display_name</div><div class="ttdoc">展示名称 DisplayName</div><div class="ttdef"><b>定义</b> variable.hpp:140</div></div>
<div class="ttc" id="aclassrm_1_1Variable_html_ae2192d1434ef12e7db2be77b8d616899"><div class="ttname"><a href="../../df/db8/classrm_1_1Variable.html#ae2192d1434ef12e7db2be77b8d616899">rm::Variable::description</a></div><div class="ttdeci">std::string description</div><div class="ttdoc">变量的描述</div><div class="ttdef"><b>定义</b> variable.hpp:142</div></div>
</div><!-- fragment --><p>然后在客户端中直接读取变量节点。</p>
<div class="fragment"><div class="line"><span class="comment">// client.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/dfe/client_8hpp.html">rmvl/opcua/client.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="../../da/d78/classrm_1_1Client.html">rm::Client</a> cli(<span class="stringliteral">&quot;opc.tcp://127.0.0.1:4840&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 使用管道运算符 &quot;|&quot; 进行路径搜索，寻找待读取的变量</span></div>
<div class="line">    <span class="keyword">auto</span> node = <a class="code hl_function" href="../../d3/da8/group__opcua.html#ga041532456b96e8dac325a89f51b089e6">rm::nodeObjectsFolder</a> | cli.find(<span class="stringliteral">&quot;number&quot;</span>);</div>
<div class="line">    <span class="comment">// 读取变量</span></div>
<div class="line">    <a class="code hl_class" href="../../df/db8/classrm_1_1Variable.html">rm::Variable</a> target = cli.read(node);</div>
<div class="line">    <span class="comment">// 判断是否为空</span></div>
<div class="line">    <span class="keywordflow">if</span> (target.<a class="code hl_function" href="../../df/db8/classrm_1_1Variable.html#ab1463cebb6f4ae2d756ace4e61e4dd61">empty</a>())</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_define" href="../../d0/de1/group__core.html#ga9fdfbca3e848ceaea5debb80759891e2">ERROR_</a>(<span class="stringliteral">&quot;Failed to read the variable.&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// 使用静态成员函数将 target 转化为目标格式，并打印</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;%f\n&quot;</span>, <a class="code hl_function" href="../../df/db8/classrm_1_1Variable.html#a52e829435a14b7a4b02ed6bba1a57955">rm::Variable::cast&lt;double&gt;</a>(target));</div>
<div class="line">}</div>
<div class="ttc" id="aclassrm_1_1Variable_html_a52e829435a14b7a4b02ed6bba1a57955"><div class="ttname"><a href="../../df/db8/classrm_1_1Variable.html#a52e829435a14b7a4b02ed6bba1a57955">rm::Variable::cast</a></div><div class="ttdeci">Tp cast()</div><div class="ttdoc">将变量节点转化为指定类型的数据</div><div class="ttdef"><b>定义</b> variable.hpp:236</div></div>
<div class="ttc" id="aclassrm_1_1Variable_html_ab1463cebb6f4ae2d756ace4e61e4dd61"><div class="ttname"><a href="../../df/db8/classrm_1_1Variable.html#ab1463cebb6f4ae2d756ace4e61e4dd61">rm::Variable::empty</a></div><div class="ttdeci">constexpr bool empty() const</div><div class="ttdoc">判断变量节点是否为空</div><div class="ttdef"><b>定义</b> variable.hpp:217</div></div>
<div class="ttc" id="aclient_8hpp_html"><div class="ttname"><a href="../../d2/dfe/client_8hpp.html">client.hpp</a></div><div class="ttdoc">OPC UA 客户端</div></div>
<div class="ttc" id="agroup__core_html_ga9fdfbca3e848ceaea5debb80759891e2"><div class="ttname"><a href="../../d0/de1/group__core.html#ga9fdfbca3e848ceaea5debb80759891e2">ERROR_</a></div><div class="ttdeci">#define ERROR_(...)</div><div class="ttdef"><b>定义</b> util.hpp:50</div></div>
<div class="ttc" id="agroup__opcua_html_ga041532456b96e8dac325a89f51b089e6"><div class="ttname"><a href="../../d3/da8/group__opcua.html#ga041532456b96e8dac325a89f51b089e6">rm::nodeObjectsFolder</a></div><div class="ttdeci">constexpr NodeId nodeObjectsFolder(0, UA_NS0ID_OBJECTSFOLDER)</div><div class="ttdoc">对象节点：ObjectsFolder 节点 ID</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md258"></a>
2.3 方法</h2>
<p>在服务器中添加两数之和的方法节点，供客户端调用。</p>
<div class="fragment"><div class="line"><span class="comment">// server.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../df/d0a/server_8hpp.html">rmvl/opcua/server.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="../../d4/d06/classrm_1_1Server.html">rm::Server</a> srv(4840);</div>
<div class="line">    srv.start();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 定义方法</span></div>
<div class="line">    <a class="code hl_struct" href="../../d2/d23/structrm_1_1Method.html">rm::Method</a> method;</div>
<div class="line">    method.<a class="code hl_variable" href="../../d2/d23/structrm_1_1Method.html#a522f942626277a8867b179de55343ff8">browse_name</a> = <span class="stringliteral">&quot;add&quot;</span>;</div>
<div class="line">    method.<a class="code hl_variable" href="../../d2/d23/structrm_1_1Method.html#a788d4252a3ee5193159cbf20df06d6f4">display_name</a> = <span class="stringliteral">&quot;Add&quot;</span>;</div>
<div class="line">    method.<a class="code hl_variable" href="../../d2/d23/structrm_1_1Method.html#a3b6e001428888146e110283033414226">description</a> = <span class="stringliteral">&quot;两数之和&quot;</span>;</div>
<div class="line">    <span class="comment">// 定义函数传入参数 iargs 的类型</span></div>
<div class="line">    method.<a class="code hl_variable" href="../../d2/d23/structrm_1_1Method.html#a34efd80aa625fbe427cdeef38f043e57">iargs</a> = {{<span class="stringliteral">&quot;Number 1&quot;</span>, UA_TYPES_INT32}, {<span class="stringliteral">&quot;Number 2&quot;</span>, UA_TYPES_INT32}};</div>
<div class="line">    <span class="comment">// 定义函数返回值 oargs 的类型</span></div>
<div class="line">    method.<a class="code hl_variable" href="../../d2/d23/structrm_1_1Method.html#aab157329af3899e55bb21e4df4f8b583">oargs</a> = {{<span class="stringliteral">&quot;Sum&quot;</span>, UA_TYPES_INT32}};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">        1. 数据类型均使用在 open62541 中定义的 UA_TYPES_ 作为前缀的宏</span></div>
<div class="line"><span class="comment">        2. {&quot;Number 1&quot;, UA_TYPES_INT32} 的部分是 rm::Argument 的聚合类，表示方法的参数</span></div>
<div class="line"><span class="comment">        3. 允许有多个返回值，即 oargs 的长度允许 &gt; 1</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 方法的函数指针，无捕获列表的 lambda 表达式可发生向函数指针的隐式转换，因此可以使用 &quot;=&quot; 完成赋值</span></div>
<div class="line">    method.<a class="code hl_variable" href="../../d2/d23/structrm_1_1Method.html#a78aabc42b1a99e9738bc1ecc35c094a2">func</a> = [](UA_Server *, <span class="keyword">const</span> UA_NodeId *, <span class="keywordtype">void</span> *, <span class="keyword">const</span> UA_NodeId *, <span class="keywordtype">void</span> *, <span class="keyword">const</span> UA_NodeId *,</div>
<div class="line">                     <span class="keywordtype">void</span> *, size_t, <span class="keyword">const</span> UA_Variant *input, size_t, UA_Variant *output) -&gt; UA_StatusCode {</div>
<div class="line">        int32_t num1 = *<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(input[0].data);</div>
<div class="line">        int32_t num2 = *<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(input[1].data);</div>
<div class="line">        int32_t retval = num1 + num2;</div>
<div class="line">        <span class="keywordflow">return</span> UA_Variant_setScalarCopy(output, &amp;retval, &amp;UA_TYPES[UA_TYPES_INT32]);</div>
<div class="line">    };</div>
<div class="line">    <span class="comment">// 方法节点添加至服务器</span></div>
<div class="line">    server.addMethodNode(method);</div>
<div class="line"> </div>
<div class="line">    srv.join();</div>
<div class="line">}</div>
<div class="ttc" id="astructrm_1_1Method_html"><div class="ttname"><a href="../../d2/d23/structrm_1_1Method.html">rm::Method</a></div><div class="ttdoc">OPC UA 方法</div><div class="ttdef"><b>定义</b> method.hpp:41</div></div>
<div class="ttc" id="astructrm_1_1Method_html_a34efd80aa625fbe427cdeef38f043e57"><div class="ttname"><a href="../../d2/d23/structrm_1_1Method.html#a34efd80aa625fbe427cdeef38f043e57">rm::Method::iargs</a></div><div class="ttdeci">std::vector&lt; Argument &gt; iargs</div><div class="ttdoc">传入参数列表</div><div class="ttdef"><b>定义</b> method.hpp:67</div></div>
<div class="ttc" id="astructrm_1_1Method_html_a3b6e001428888146e110283033414226"><div class="ttname"><a href="../../d2/d23/structrm_1_1Method.html#a3b6e001428888146e110283033414226">rm::Method::description</a></div><div class="ttdeci">std::string description</div><div class="ttdoc">方法的描述</div><div class="ttdef"><b>定义</b> method.hpp:64</div></div>
<div class="ttc" id="astructrm_1_1Method_html_a522f942626277a8867b179de55343ff8"><div class="ttname"><a href="../../d2/d23/structrm_1_1Method.html#a522f942626277a8867b179de55343ff8">rm::Method::browse_name</a></div><div class="ttdeci">std::string browse_name</div><div class="ttdoc">浏览名称 BrowseName</div><div class="ttdef"><b>定义</b> method.hpp:52</div></div>
<div class="ttc" id="astructrm_1_1Method_html_a788d4252a3ee5193159cbf20df06d6f4"><div class="ttname"><a href="../../d2/d23/structrm_1_1Method.html#a788d4252a3ee5193159cbf20df06d6f4">rm::Method::display_name</a></div><div class="ttdeci">std::string display_name</div><div class="ttdoc">展示名称 DisplayName</div><div class="ttdef"><b>定义</b> method.hpp:61</div></div>
<div class="ttc" id="astructrm_1_1Method_html_a78aabc42b1a99e9738bc1ecc35c094a2"><div class="ttname"><a href="../../d2/d23/structrm_1_1Method.html#a78aabc42b1a99e9738bc1ecc35c094a2">rm::Method::func</a></div><div class="ttdeci">UA_MethodCallback func</div><div class="ttdoc">方法回调函数</div><div class="ttdef"><b>定义</b> method.hpp:83</div></div>
<div class="ttc" id="astructrm_1_1Method_html_aab157329af3899e55bb21e4df4f8b583"><div class="ttname"><a href="../../d2/d23/structrm_1_1Method.html#aab157329af3899e55bb21e4df4f8b583">rm::Method::oargs</a></div><div class="ttdeci">std::vector&lt; Argument &gt; oargs</div><div class="ttdoc">传出参数列表</div><div class="ttdef"><b>定义</b> method.hpp:70</div></div>
</div><!-- fragment --><p>在客户端调用指定方法。</p>
<div class="fragment"><div class="line"><span class="comment">// client.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/dfe/client_8hpp.html">rmvl/opcua/client.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="../../da/d78/classrm_1_1Client.html">rm::Client</a> cli(<span class="stringliteral">&quot;opc.tcp://127.0.0.1:4840&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 设置输入参数，1 和 2 是 Int32 类型的，因此可以直接隐式构造</span></div>
<div class="line">    std::vector&lt;rm::Variable&gt; input = {1, 2};</div>
<div class="line">    <span class="comment">// 设置输出参数，用来存储结果</span></div>
<div class="line">    std::vector&lt;rm::Variable&gt; output;</div>
<div class="line">    <span class="comment">// 调用方法，判断调用是否成功</span></div>
<div class="line">    <span class="keywordflow">if</span> (!cli.call(<span class="stringliteral">&quot;add&quot;</span>, input, output))</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_define" href="../../d0/de1/group__core.html#ga9fdfbca3e848ceaea5debb80759891e2">ERROR_</a>(<span class="stringliteral">&quot;Failed to call the method&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// 输出结果</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;retval = %d\n&quot;</span>, <a class="code hl_function" href="../../df/db8/classrm_1_1Variable.html#a52e829435a14b7a4b02ed6bba1a57955">rm::Variable::cast&lt;int&gt;</a>(output.front()));</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md259"></a>
2.4 对象</h2>
<p>在服务器中添加对象节点：</p>
<ul>
<li>A<ul>
<li>B1<ul>
<li>C1: <code>3.14</code></li>
<li>C2: <code>666</code></li>
</ul>
</li>
<li>B2<ul>
<li>C3: <code>"xyz"</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// server.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../df/d0a/server_8hpp.html">rmvl/opcua/server.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="../../d4/d06/classrm_1_1Server.html">rm::Server</a> srv(4840);</div>
<div class="line">    srv.start();</div>
<div class="line">    <span class="comment">// 准备对象节点数据 A</span></div>
<div class="line">    <a class="code hl_class" href="../../d8/d9b/classrm_1_1Object.html">rm::Object</a> a;</div>
<div class="line">    a.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#aa3acefd9587e6669ab311f8d11f8c94b">browse_name</a> = a.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#a38ff99ec5033cc00b4ea87570cefe493">description</a> = a.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#a82d108ca995445032d4cae85906b4771">display_name</a> = <span class="stringliteral">&quot;A&quot;</span>;</div>
<div class="line">    <span class="comment">// 添加对象节点 A 至服务器</span></div>
<div class="line">    <span class="keyword">auto</span> node_a = srv.addObjectNode(a);</div>
<div class="line">    <span class="comment">// 准备对象节点数据 B1</span></div>
<div class="line">    <a class="code hl_class" href="../../d8/d9b/classrm_1_1Object.html">rm::Object</a> b1;</div>
<div class="line">    b1.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#aa3acefd9587e6669ab311f8d11f8c94b">browse_name</a> = b1.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#a38ff99ec5033cc00b4ea87570cefe493">description</a> = b1.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#a82d108ca995445032d4cae85906b4771">display_name</a> = <span class="stringliteral">&quot;B1&quot;</span>;</div>
<div class="line">    <span class="comment">// 准备 B1 的变量节点 C1</span></div>
<div class="line">    <a class="code hl_class" href="../../df/db8/classrm_1_1Variable.html">rm::Variable</a> c1 = 3.14;</div>
<div class="line">    c1.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#a3d20725d0f1a56474ff7bf90f57e7c8d">browse_name</a> = c1.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ae2192d1434ef12e7db2be77b8d616899">description</a> = c1.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ad3099ea3e54575de460b272a1c496203">display_name</a> = <span class="stringliteral">&quot;C1&quot;</span>;</div>
<div class="line">    b1.<a class="code hl_function" href="../../d8/d9b/classrm_1_1Object.html#aa61e1bab707b656b224827f4746e259b">add</a>(c1);</div>
<div class="line">    <span class="comment">// 准备 B1 的变量节点 C2</span></div>
<div class="line">    <a class="code hl_class" href="../../df/db8/classrm_1_1Variable.html">rm::Variable</a> c2 = 666;</div>
<div class="line">    c2.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#a3d20725d0f1a56474ff7bf90f57e7c8d">browse_name</a> = c2.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ae2192d1434ef12e7db2be77b8d616899">description</a> = c2.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ad3099ea3e54575de460b272a1c496203">display_name</a> = <span class="stringliteral">&quot;C2&quot;</span>;</div>
<div class="line">    b1.<a class="code hl_function" href="../../d8/d9b/classrm_1_1Object.html#aa61e1bab707b656b224827f4746e259b">add</a>(c2);</div>
<div class="line">    <span class="comment">// 添加对象节点 B1 至服务器</span></div>
<div class="line">    srv.addObjectNode(b1, node_a);</div>
<div class="line">    <span class="comment">// 准备对象节点数据 B2</span></div>
<div class="line">    <a class="code hl_class" href="../../d8/d9b/classrm_1_1Object.html">rm::Object</a> b2;</div>
<div class="line">    b2.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#aa3acefd9587e6669ab311f8d11f8c94b">browse_name</a> = b2.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#a38ff99ec5033cc00b4ea87570cefe493">description</a> = b2.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#a82d108ca995445032d4cae85906b4771">display_name</a> = <span class="stringliteral">&quot;B2&quot;</span>;</div>
<div class="line">    <span class="comment">// 准备 B2 的变量节点 C3</span></div>
<div class="line">    <a class="code hl_class" href="../../df/db8/classrm_1_1Variable.html">rm::Variable</a> c3 = <span class="stringliteral">&quot;xyz&quot;</span>;</div>
<div class="line">    c3.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#a3d20725d0f1a56474ff7bf90f57e7c8d">browse_name</a> = c3.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ae2192d1434ef12e7db2be77b8d616899">description</a> = c3.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ad3099ea3e54575de460b272a1c496203">display_name</a> = <span class="stringliteral">&quot;C3&quot;</span>;</div>
<div class="line">    b2.<a class="code hl_function" href="../../d8/d9b/classrm_1_1Object.html#aa61e1bab707b656b224827f4746e259b">add</a>(c3);</div>
<div class="line">    <span class="comment">// 添加对象节点 B2 至服务器</span></div>
<div class="line">    srv.addObjectNode(b2, node_a);</div>
<div class="line"> </div>
<div class="line">    srv.join();</div>
<div class="line">}</div>
<div class="ttc" id="aclassrm_1_1Object_html"><div class="ttname"><a href="../../d8/d9b/classrm_1_1Object.html">rm::Object</a></div><div class="ttdoc">OPC UA 对象</div><div class="ttdef"><b>定义</b> object.hpp:133</div></div>
<div class="ttc" id="aclassrm_1_1Object_html_a38ff99ec5033cc00b4ea87570cefe493"><div class="ttname"><a href="../../d8/d9b/classrm_1_1Object.html#a38ff99ec5033cc00b4ea87570cefe493">rm::Object::description</a></div><div class="ttdeci">std::string description</div><div class="ttdoc">对象的描述 - zh-CN</div><div class="ttdef"><b>定义</b> object.hpp:177</div></div>
<div class="ttc" id="aclassrm_1_1Object_html_a82d108ca995445032d4cae85906b4771"><div class="ttname"><a href="../../d8/d9b/classrm_1_1Object.html#a82d108ca995445032d4cae85906b4771">rm::Object::display_name</a></div><div class="ttdeci">std::string display_name</div><div class="ttdoc">展示名称 DisplayName</div><div class="ttdef"><b>定义</b> object.hpp:175</div></div>
<div class="ttc" id="aclassrm_1_1Object_html_aa3acefd9587e6669ab311f8d11f8c94b"><div class="ttname"><a href="../../d8/d9b/classrm_1_1Object.html#aa3acefd9587e6669ab311f8d11f8c94b">rm::Object::browse_name</a></div><div class="ttdeci">std::string browse_name</div><div class="ttdoc">浏览名称 BrowseName</div><div class="ttdef"><b>定义</b> object.hpp:166</div></div>
<div class="ttc" id="aclassrm_1_1Object_html_aa61e1bab707b656b224827f4746e259b"><div class="ttname"><a href="../../d8/d9b/classrm_1_1Object.html#aa61e1bab707b656b224827f4746e259b">rm::Object::add</a></div><div class="ttdeci">void add(const Variable &amp;variable)</div><div class="ttdoc">添加（额外的）变量节点至 rm::Object 对象中</div><div class="ttdef"><b>定义</b> object.hpp:196</div></div>
</div><!-- fragment --><p>在客户端寻找 <code>C2</code> 和 <code>C3</code> 并打印。</p>
<div class="fragment"><div class="line"><span class="comment">// client.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/dfe/client_8hpp.html">rmvl/opcua/client.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="../../da/d78/classrm_1_1Client.html">rm::Client</a> cli(<span class="stringliteral">&quot;opc.tcp://127.0.0.1:4840&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 路径搜索寻找 C2</span></div>
<div class="line">    <span class="keyword">auto</span> node_c2 = <a class="code hl_function" href="../../d3/da8/group__opcua.html#ga041532456b96e8dac325a89f51b089e6">rm::nodeObjectsFolder</a> | cli.find(<span class="stringliteral">&quot;A&quot;</span>) | cli.find(<span class="stringliteral">&quot;B1&quot;</span>) | cli.find(<span class="stringliteral">&quot;C2&quot;</span>);</div>
<div class="line">    <a class="code hl_class" href="../../df/db8/classrm_1_1Variable.html">rm::Variable</a> c2;</div>
<div class="line">    cli.read(node_c2, c2);</div>
<div class="line">    std::cout &lt;&lt; rm::Variable::cast&lt;int&gt;(c2) &lt;&lt; std::endl;</div>
<div class="line">    <span class="comment">// 路径搜索寻找 C3</span></div>
<div class="line">    <span class="keyword">auto</span> node_c3 = <a class="code hl_function" href="../../d3/da8/group__opcua.html#ga041532456b96e8dac325a89f51b089e6">rm::nodeObjectsFolder</a> | cli.find(<span class="stringliteral">&quot;A&quot;</span>) | cli.find(<span class="stringliteral">&quot;B2&quot;</span>) | cli.find(<span class="stringliteral">&quot;C3&quot;</span>);</div>
<div class="line">    <a class="code hl_class" href="../../df/db8/classrm_1_1Variable.html">rm::Variable</a> c3;</div>
<div class="line">    cli.read(node_c3, c3);</div>
<div class="line">    std::cout &lt;&lt; rm::Variable::cast&lt;const char *&gt;(c3) &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md260"></a>
2.5 视图</h2>
<p>在 <code>nodeObjectsFolder</code> 中先添加 <code>A/num1</code>、<code>num2</code> 2 个变量节点，并将 <code>num1</code> 和 <code>num2</code> 加入视图，下面的示例演示在 <b>服务器</b> 中创建并添加视图节点。若要在客户端中进行此操作，创建并添加视图节点的步骤基本一致，这里不做展示。需要注意的是，在客户端中创建并添加视图节点，需要提前在服务器中加入对应的（变量、方法、对象……）节点</p>
<div class="fragment"><div class="line"><span class="comment">// server.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../df/d0a/server_8hpp.html">rmvl/opcua/server.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="../../d4/d06/classrm_1_1Server.html">rm::Server</a> srv(4840);</div>
<div class="line">    srv.start();</div>
<div class="line">    <span class="comment">// 准备对象节点数据 A</span></div>
<div class="line">    <a class="code hl_class" href="../../d8/d9b/classrm_1_1Object.html">rm::Object</a> a;</div>
<div class="line">    a.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#aa3acefd9587e6669ab311f8d11f8c94b">browse_name</a> = a.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#a38ff99ec5033cc00b4ea87570cefe493">description</a> = a.<a class="code hl_variable" href="../../d8/d9b/classrm_1_1Object.html#a82d108ca995445032d4cae85906b4771">display_name</a> = <span class="stringliteral">&quot;A&quot;</span>;</div>
<div class="line">    <span class="comment">// 这里使用宏来创建 num1</span></div>
<div class="line">    <a class="code hl_define" href="../../d3/da8/group__opcua.html#ga2c945fd1e774a90c267570b1cc3016c6">uaCreateVariable</a>(num1, 1);</div>
<div class="line">    a.<a class="code hl_function" href="../../d8/d9b/classrm_1_1Object.html#aa61e1bab707b656b224827f4746e259b">add</a>(num1);</div>
<div class="line">    <span class="keyword">auto</span> node_a = srv.addObjectNode(a);</div>
<div class="line">    <span class="keyword">auto</span> node_num1 = node_a | srv.find(<span class="stringliteral">&quot;num1&quot;</span>);</div>
<div class="line">    <span class="comment">// 这里使用宏来创建 num2</span></div>
<div class="line">    <a class="code hl_define" href="../../d3/da8/group__opcua.html#ga2c945fd1e774a90c267570b1cc3016c6">uaCreateVariable</a>(num2, 2);</div>
<div class="line">    <span class="keyword">auto</span> node_num2 = srv.addVariableNode(num2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 创建视图</span></div>
<div class="line">    <a class="code hl_class" href="../../d2/de9/classrm_1_1View.html">rm::View</a> num_view;</div>
<div class="line">    <span class="comment">// 添加节点至视图（这里使用的是变量节点的 NodeId，实际上其他节点也是允许的）</span></div>
<div class="line">    num_view.<a class="code hl_function" href="../../d2/de9/classrm_1_1View.html#aa81dee0ce2146d0d1b9ef555b11f6726">add</a>(node_num1, node_num2);</div>
<div class="line">    <span class="comment">// 添加至服务器</span></div>
<div class="line">    srv.addViewNode(num_view);</div>
<div class="line">    srv.join();</div>
<div class="line">}</div>
<div class="ttc" id="aclassrm_1_1View_html"><div class="ttname"><a href="../../d2/de9/classrm_1_1View.html">rm::View</a></div><div class="ttdoc">OPC UA 视图</div><div class="ttdef"><b>定义</b> view.hpp:24</div></div>
<div class="ttc" id="aclassrm_1_1View_html_aa81dee0ce2146d0d1b9ef555b11f6726"><div class="ttname"><a href="../../d2/de9/classrm_1_1View.html#aa81dee0ce2146d0d1b9ef555b11f6726">rm::View::add</a></div><div class="ttdeci">void add(NodeId_ &amp;&amp;...node_id)</div><div class="ttdoc">添加节点 ID</div><div class="ttdef"><b>定义</b> view.hpp:70</div></div>
<div class="ttc" id="agroup__opcua_html_ga2c945fd1e774a90c267570b1cc3016c6"><div class="ttname"><a href="../../d3/da8/group__opcua.html#ga2c945fd1e774a90c267570b1cc3016c6">uaCreateVariable</a></div><div class="ttdeci">#define uaCreateVariable(val,...)</div><div class="ttdoc">创建变量，BrowseName、DisplayName、Description 均为变量类型的名称</div><div class="ttdef"><b>定义</b> variable.hpp:272</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md261"></a>
2.6 监视</h2>
<p>在服务器中添加待监视的变量节点</p>
<div class="fragment"><div class="line"><span class="comment">// server.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../df/d0a/server_8hpp.html">rmvl/opcua/server.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="../../d4/d06/classrm_1_1Server.html">rm::Server</a> srv(4840);</div>
<div class="line">    srv.start();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 定义 int 型变量</span></div>
<div class="line">    <a class="code hl_class" href="../../df/db8/classrm_1_1Variable.html">rm::Variable</a> num = 100;</div>
<div class="line">    num.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#a3d20725d0f1a56474ff7bf90f57e7c8d">browse_name</a> = <span class="stringliteral">&quot;number&quot;</span>;</div>
<div class="line">    num.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ad3099ea3e54575de460b272a1c496203">display_name</a> = <span class="stringliteral">&quot;Number&quot;</span>;</div>
<div class="line">    num.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ae2192d1434ef12e7db2be77b8d616899">description</a> = <span class="stringliteral">&quot;数字&quot;</span>;</div>
<div class="line">    <span class="comment">// 添加到服务器的默认位置</span></div>
<div class="line">    srv.addVariableNode(num);</div>
<div class="line"> </div>
<div class="line">    srv.join();</div>
<div class="line">}</div>
</div><!-- fragment --><p>在客户端 1 中修改变量节点的数据</p>
<div class="fragment"><div class="line"><span class="comment">// client_1.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/dfe/client_8hpp.html">rmvl/opcua/client.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="../../da/d78/classrm_1_1Client.html">rm::Client</a> cli(<span class="stringliteral">&quot;opc.tcp://127.0.0.1:4840&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> node = <a class="code hl_function" href="../../d3/da8/group__opcua.html#ga041532456b96e8dac325a89f51b089e6">rm::nodeObjectsFolder</a> | cli.find(<span class="stringliteral">&quot;number&quot;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; ++i)</div>
<div class="line">    {</div>
<div class="line">        std::this_thread::sleep_for(1s);</div>
<div class="line">        <span class="comment">// 写入数据，i + 200 隐式构造成了 rm::Variable</span></div>
<div class="line">        <span class="keywordtype">bool</span> success = cli.write(node, i + 200);</div>
<div class="line">        <span class="keywordflow">if</span> (!success)</div>
<div class="line">            <a class="code hl_define" href="../../d0/de1/group__core.html#ga9fdfbca3e848ceaea5debb80759891e2">ERROR_</a>(<span class="stringliteral">&quot;Failed to write data to the variable.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>在客户端 2 中监视变量节点</p>
<div class="fragment"><div class="line"><span class="comment">// client_2.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/dfe/client_8hpp.html">rmvl/opcua/client.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> onChange(UA_Client *, UA_UInt32, <span class="keywordtype">void</span> *, UA_UInt32, <span class="keywordtype">void</span> *, UA_DataValue *value)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> receive_data = *<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(value-&gt;value.data);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Data (n=number) was changed to: %d\n&quot;</span>, receive_data);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="../../da/d78/classrm_1_1Client.html">rm::Client</a> cli(<span class="stringliteral">&quot;opc.tcp://127.0.0.1:4840&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> node = <a class="code hl_function" href="../../d3/da8/group__opcua.html#ga041532456b96e8dac325a89f51b089e6">rm::nodeObjectsFolder</a> | cli.find(<span class="stringliteral">&quot;number&quot;</span>);</div>
<div class="line">    <span class="comment">// 监视变量，这里的 onChange 同样可以写成无捕获列表的 lambda 表达式，因为存在隐式转换</span></div>
<div class="line">    client.monitor(node, onChange, 5);</div>
<div class="line">    <span class="comment">// 线程阻塞</span></div>
<div class="line">    client.spin();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="opcua_pub_sub"></a>
3. 发布/订阅</h1>
<p>这是一段来自 <a href="https://www.open62541.org">open62541 手册</a>中有关 PubSub 的介绍。</p>
<blockquote class="doxtable">
<p>&zwj;在 PubSub 中，参与的 OPC UA 应用程序扮演发布者和订阅者的角色。发布者是数据的来源，而订阅者则使用该数据。PubSub 中的通信是基于消息的。发布者将消息发送到面向消息的中间件，而不知道可能有哪些订阅者（如果有）。同样，订阅者表达对特定类型数据的兴趣，并处理包含此数据的消息，而不知道有哪些发布者。</p>
<p>面向消息的中间件是支持在分布式系统之间发送和接收消息的软件或硬件基础设施。OPC UA PubSub 支持两种不同的面向消息的中间件变体，即 <b>无代理形式</b> 和 <b>基于代理的形式</b> 。在无代理形式中，面向消息的中间件是能够路由基于数据报的消息的网络基础设施。订阅者和发布者使用 UDP 等数据报协议。在基于代理的形式中，消息中间件的核心组件是消息代理。订阅者和发布者使用 AMQP 或 MQTT 等标准消息传递协议与代理进行通信。</p>
<p>这使得 PubSub 适合需要位置独立性和（或）可扩展性的应用程序。</p>
<p>OPC UA 的发布/订阅（PubSub）扩展可实现快速高效的通信。PubSub 扩展与协议无关，可与基于代理的协议（如 MQTT 和 AMQP）或无代理实现（如 UDP 多播）一起使用。</p>
<p>PubSub 的配置模型使用以下组件 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>  {</div>
<div class="line">    UA_PUBSUB_COMPONENT_CONNECTION,</div>
<div class="line">    UA_PUBSUB_COMPONENT_WRITERGROUP,</div>
<div class="line">    UA_PUBSUB_COMPONENT_DATASETWRITER,</div>
<div class="line">    UA_PUBSUB_COMPONENT_READERGROUP,</div>
<div class="line">    UA_PUBSUB_COMPONENT_DATASETREADER</div>
<div class="line">} UA_PubSubComponentEnumType;</div>
</div><!-- fragment --><p>open62541 PubSub API 使用以下方案</p><ul>
<li>为所需的 PubSub 元素创建配置</li>
<li>调用 <code>add[element]</code> 函数并传入配置</li>
<li><code>add[element]</code> 函数返回内部创建的元素的唯一 <code>UA_NodeId</code> </li>
</ul>
</blockquote>
<p>有关 API 使用的更多详细信息，请查看 <a href="https://www.open62541.org/doc/master/pubsub.html">PubSub 教程</a>。</p>
<h2><a class="anchor" id="autotoc_md262"></a>
3.1 无代理 Pub/Sub</h2>
<p>RMVL 提供了基于 <code>UDP</code> 传输协议的 Broker-less 即无代理的发布订阅机制，目前支持 <code>UADP</code> 的消息映射方式，对应的枚举类型是 <code>TransportID::UDP_UADP</code>。</p>
<p>需要留意的是，OPC UA 的发布订阅模型仍然是建立在 <a class="el" href="#opcua_server_client">2. 服务器/客户端</a> 模型之上的，此外 <a class="el" href="../../d3/da8/group__opcua.html">基于 open62541 的 OPC UA 二次开发库</a> 的 PubSub 在实现上是继承于 <a class="el" href="../../d4/d06/classrm_1_1Server.html" title="OPC UA 服务器">rm::Server</a> 的，因此，RMVL 的发布订阅模型在使用时具备服务器的所有功能，初始化、释放资源等操作与服务器完全一致。</p>
<p><b>创建发布者</b></p>
<div class="fragment"><div class="line"><span class="comment">// publisher.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../da/d24/publisher_8hpp.html">rmvl/opcua/publisher.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// 创建 OPC UA 发布者，端口为 4840</span></div>
<div class="line">    <a class="code hl_class" href="../../d7/dfc/classrm_1_1Publisher.html">rm::Publisher&lt;rm::TransportID::UDP_UADP&gt;</a> pub(<span class="stringliteral">&quot;DemoNumberPub&quot;</span>, <span class="stringliteral">&quot;opc.udp://224.0.0.22:4840&quot;</span>);</div>
<div class="line">    <span class="comment">// 添加变量节点至发布者自身的服务器中</span></div>
<div class="line">    <a class="code hl_class" href="../../df/db8/classrm_1_1Variable.html">rm::Variable</a> num = 3.14;</div>
<div class="line">    num.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#a3d20725d0f1a56474ff7bf90f57e7c8d">browse_name</a> = <span class="stringliteral">&quot;number&quot;</span>;</div>
<div class="line">    num.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ad3099ea3e54575de460b272a1c496203">display_name</a> = <span class="stringliteral">&quot;Number&quot;</span>;</div>
<div class="line">    num.<a class="code hl_variable" href="../../df/db8/classrm_1_1Variable.html#ae2192d1434ef12e7db2be77b8d616899">description</a> = <span class="stringliteral">&quot;数字&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> num_node = pub.addVariableNode(num);</div>
<div class="line">    <span class="comment">// 发布者的服务器运行</span></div>
<div class="line">    pub.start();</div>
<div class="line">    <span class="comment">// 准备待发布的数据</span></div>
<div class="line">    std::vector&lt;PublishedDataSet&gt; pds_list;</div>
<div class="line">    pds_list.emplace_back(<span class="stringliteral">&quot;Number 1&quot;</span>, num_node);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 发布数据</span></div>
<div class="line">    pub.publish(pds_list, 50);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* other code */</span></div>
<div class="line">    <span class="comment">/* 例如 num_node 所对应的值可以直接在这里修改 */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 线程阻塞，直到调用了 pub.stop()，线程才会继续执行。</span></div>
<div class="line">    pub.join();</div>
<div class="line">}</div>
<div class="ttc" id="aclassrm_1_1Publisher_html"><div class="ttname"><a href="../../d7/dfc/classrm_1_1Publisher.html">rm::Publisher</a></div><div class="ttdoc">OPC UA 发布者</div><div class="ttdef"><b>定义</b> publisher.hpp:45</div></div>
<div class="ttc" id="apublisher_8hpp_html"><div class="ttname"><a href="../../da/d24/publisher_8hpp.html">publisher.hpp</a></div><div class="ttdoc">OPC UA 发布者</div></div>
</div><!-- fragment --><p><b>创建订阅者</b></p>
<div class="fragment"><div class="line"><span class="comment">// subscriber.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d8/df0/subscriber_8hpp.html">rmvl/opcua/subscriber.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// 创建 OPC UA 订阅者</span></div>
<div class="line">    <a class="code hl_class" href="../../d4/dea/classrm_1_1Subscriber.html">rm::Subscriber&lt;rm::TransportID::UDP_UADP&gt;</a> sub(<span class="stringliteral">&quot;DemoNumberSub&quot;</span>, <span class="stringliteral">&quot;opc.udp://224.0.0.22:4840&quot;</span>, 4841);</div>
<div class="line">    <span class="comment">// 订阅者的服务器运行</span></div>
<div class="line">    sub.start();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 准备需要订阅的数据</span></div>
<div class="line">    <span class="comment">// 这里只订阅 1 个，如果订阅多个请使用 std::vector</span></div>
<div class="line">    <a class="code hl_struct" href="../../d4/d81/structrm_1_1FieldMetaData.html">rm::FieldMetaData</a> meta_data(<span class="stringliteral">&quot;Number 1&quot;</span>, UA_TYPES_DOUBLE, UA_VALUERANK_SCALAR);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* 也可以通过创建变量对 meta_data 进行初始化，例如以下代码</span></div>
<div class="line"><span class="comment">    rm::Variable num = 1.0; // 这个 1.0 只是代表是个 Double 类型的数据 </span></div>
<div class="line"><span class="comment">    num.browse_name = &quot;Number 1&quot;;</span></div>
<div class="line"><span class="comment">    rm::FieldMetaData meta_data = num;</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 订阅数据，第 2 个参数传入的是 std::vector 类型的数据，单个数据请使用初始化列表</span></div>
<div class="line">    <span class="keyword">auto</span> nodes = sub.subscribe(<span class="stringliteral">&quot;DemoNumberPub&quot;</span>, {meta_data});</div>
<div class="line">    <span class="comment">// 订阅接收的数据均存放在订阅者自身的服务器中，请使用服务器端变量的写操作进行访问</span></div>
<div class="line">    <span class="comment">// 订阅返回值是一个 NodeId 列表，存放订阅接收的数据的 NodeId</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 读取订阅的已更新的数据</span></div>
<div class="line">    <span class="keyword">auto</span> sub_val = sub.read(nodes.front());</div>
<div class="line">    std::printf(<span class="stringliteral">&quot;Sub value [1] = %f\n&quot;</span>, sub_val.cast&lt;<span class="keywordtype">double</span>&gt;());</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 线程阻塞，直到调用了 sub.stop()，线程才会继续执行。</span></div>
<div class="line">    sub.join();</div>
<div class="line">}</div>
<div class="ttc" id="aclassrm_1_1Subscriber_html"><div class="ttname"><a href="../../d4/dea/classrm_1_1Subscriber.html">rm::Subscriber</a></div><div class="ttdoc">OPC UA 订阅者</div><div class="ttdef"><b>定义</b> subscriber.hpp:78</div></div>
<div class="ttc" id="astructrm_1_1FieldMetaData_html"><div class="ttname"><a href="../../d4/d81/structrm_1_1FieldMetaData.html">rm::FieldMetaData</a></div><div class="ttdoc">数据集字段元数据</div><div class="ttdef"><b>定义</b> subscriber.hpp:26</div></div>
<div class="ttc" id="asubscriber_8hpp_html"><div class="ttname"><a href="../../d8/df0/subscriber_8hpp.html">subscriber.hpp</a></div><div class="ttdoc">OPC UA 订阅者</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md263"></a>
3.2 有代理 Pub/Sub</h2>
<dl class="section warning"><dt>警告</dt><dd>RMVL 目前暂不支持有代理的发布订阅机制。</dd></dl>
<h1><a class="anchor" id="autotoc_md264"></a>
4. 使用技巧</h1>
<p>以下是 <a class="el" href="../../d3/da8/group__opcua.html">基于 open62541 的 OPC UA 二次开发库</a> 的使用技巧。</p>
<h2><a class="anchor" id="opcua_parameters"></a>
4.1 参数加载</h2>
<p><a class="el" href="../../d3/da8/group__opcua.html">基于 open62541 的 OPC UA 二次开发库</a> 中提供了以下几个运行时可调节参数</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">类型   </th><th class="markdownTableHeadCenter">参数名   </th><th class="markdownTableHeadCenter">默认值   </th><th class="markdownTableHeadCenter">注释    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>uint32_t</code>   </td><td class="markdownTableBodyCenter">SPIN_TIMEOUT   </td><td class="markdownTableBodyCenter">10   </td><td class="markdownTableBodyCenter">服务器超时响应的时间，单位 (ms)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>double</code>   </td><td class="markdownTableBodyCenter">SAMPLING_INTERVAL   </td><td class="markdownTableBodyCenter">2   </td><td class="markdownTableBodyCenter">服务器监视变量的采样速度，单位 (ms)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>double</code>   </td><td class="markdownTableBodyCenter">PUBLISHING_INTERVAL   </td><td class="markdownTableBodyCenter">2   </td><td class="markdownTableBodyCenter">服务器尝试发布数据变更的期望时间间隔，若数据未变更则不会发布，单位 (ms)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>uint32_t</code>   </td><td class="markdownTableBodyCenter">LIFETIME_COUNT   </td><td class="markdownTableBodyCenter">100   </td><td class="markdownTableBodyCenter">在没有发布任何消息的情况下，订阅请求所期望的能够保持活动状态的最大发布周期数    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>uint32_t</code>   </td><td class="markdownTableBodyCenter">MAX_KEEPALIVE_COUNT   </td><td class="markdownTableBodyCenter">50   </td><td class="markdownTableBodyCenter">在没有任何通知的情况下，订阅请求所期望的服务器应该发送的最大 “保活” 消息数    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>uint32_t</code>   </td><td class="markdownTableBodyCenter">MAX_NOTIFICATIONS   </td><td class="markdownTableBodyCenter">100   </td><td class="markdownTableBodyCenter">服务器应该发送的期望的最大通知数（通知是服务器向客户端报告订阅的变化的方式）    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>uint8_t</code>   </td><td class="markdownTableBodyCenter">PRIORITY   </td><td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">订阅请求的优先级   </td></tr>
</table>
<p>具体调节方式可参考引言中的 <a class="el" href="../../d1/dfb/intro.html#intro_parameters_manager">参数管理</a> 部分。</p>
<h2><a class="anchor" id="opcua_nodeset_compiler"></a>
4.2 从 XML 配置 OPC UA</h2>
<h3><a class="anchor" id="autotoc_md265"></a>
4.2.1 安装 UaModeler</h3>
<p>可使用 UaModeler 等软件进行可视化信息模型的建立，构建后可以导出为一个 <code>*.xml</code> 文件，首先先安装 UaModeler。</p>
<p><b>Windows EXE</b></p>
<ul>
<li>Windows 下可点击<a href="https://pan.baidu.com/s/1pK0gYf-yQjUoFQ-Ie7qB1w">此处</a>安装官方版本的 UaModeler 软件。</li>
</ul>
<p><b>Python</b></p>
<ul>
<li>如果有 Python 环境，也可以使用开源的 UaModeler 库，功能与官方软件基本一致。使用之前需要安装 <code>pip3</code> Python 包管理工具，安装好包管理工具后，可使用以下命令行安装 UaModeler <div class="fragment"><div class="line">pip3 install opcua-modeler</div>
<div class="line"> </div>
<div class="line"># Linux 下可以执行以下命令行运行 UaModeler</div>
<div class="line">opcua-modeler</div>
</div><!-- fragment --></li>
</ul>
<p>具体安装细节可参考 <a href="https://github.com/FreeOpcUa/opcua-modeler">opcua-modeler on Github</a> 的 README。</p>
<h3><a class="anchor" id="autotoc_md266"></a>
4.2.2 可视化配置 OPC UA 信息模型</h3>
<p>对于项目创建或导出等内容，此处不做过多介绍，可参考<a href="https://wanghao1314.blog.csdn.net/article/details/104092781">此博客</a>了解上述内容。</p>
<dl class="section note"><dt>注解</dt><dd><ul>
<li>一般的，定义对象、变量、方法等内容均按照在代码中的顺序进行定义即可，但需要注意的是，添加了方法节点后，还需要在代码中设置该方法节点执行的回调函数，可参见 <code><a class="el" href="../../d4/d06/classrm_1_1Server.html#a87f00986c9c62e2ec0f632a7b6d806f6" title="为既有的方法节点 MethodNode 设置方法的回调函数">rm::Server::setMethodNodeCallBack</a></code>。</li>
<li><code>NamespaceArray</code> 的 <code>[1]</code> 的字符串需要更改为 <code>urn:open62541.server.application</code></li>
</ul>
</dd></dl>
<h3><a class="anchor" id="autotoc_md267"></a>
4.2.3 生成 *.c/*.h 文件</h3>
<dl class="section note"><dt>注解</dt><dd>以下生成 C/C++ 文件的介绍来自 <a href="https://www.open62541.org/doc/master/nodeset_compiler.html#getting-started">open62541 nodeset-compiler</a>。</dd></dl>
<p>进入 <code>&lt;path-to-open62541&gt;/tools/nodeset_compiler</code> 文件夹，执行以下命令行</p>
<div class="fragment"><div class="line"># 获取 Opc.Ua.NodeSet2.xml 文件</div>
<div class="line">wget https://files.opcfoundation.org/schemas/UA/1.05/Opc.Ua.NodeSet2.xml</div>
<div class="line"># 将刚刚生成的 XML 文件移动至当前文件夹中，并重命名为 xxx.xml</div>
<div class="line">mv &lt;path-to-xml&gt; ./xxx.xml</div>
<div class="line"># 执行 nodeset_compiler</div>
<div class="line">python3 ./nodeset_compiler.py \</div>
<div class="line">  --types-array=UA_TYPES \</div>
<div class="line">  --existing Opc.Ua.NodeSet2.xml \</div>
<div class="line">  --xml xxx.xml \</div>
<div class="line">  myNodeSet # myNodeSet 是要生成的文件名，包含 myNodeSet.h 和 myNodeSet.c，请自行设置</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md268"></a>
4.3 不占有所有权的服务器视图</h2>
<p><code><a class="el" href="../../d4/d06/classrm_1_1Server.html" title="OPC UA 服务器">rm::Server</a></code> 使用 RAII 进行设计，一个对象占有了服务器的所有权和生命周期，当对象析构时，会自动停止并结束服务器。使用 <code><a class="el" href="../../d0/d24/classrm_1_1ServerView.html" title="OPC UA 服务器视图">rm::ServerView</a></code> 来获取不占有所有权的服务器视图，并进行变量读写、路径搜索的操作，下面用服务器视图的单元测试作为示例。</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d2/d23/structrm_1_1Method.html">rm::Method</a> method;</div>
<div class="line">method.<a class="code hl_variable" href="../../d2/d23/structrm_1_1Method.html#a522f942626277a8867b179de55343ff8">browse_name</a> = <span class="stringliteral">&quot;plus&quot;</span>;</div>
<div class="line">method.<a class="code hl_variable" href="../../d2/d23/structrm_1_1Method.html#a788d4252a3ee5193159cbf20df06d6f4">display_name</a> = <span class="stringliteral">&quot;Input + Number&quot;</span>;</div>
<div class="line">method.<a class="code hl_variable" href="../../d2/d23/structrm_1_1Method.html#a3b6e001428888146e110283033414226">description</a> = <span class="stringliteral">&quot;输入值加数&quot;</span>;</div>
<div class="line">method.<a class="code hl_variable" href="../../d2/d23/structrm_1_1Method.html#a78aabc42b1a99e9738bc1ecc35c094a2">func</a> = [](UA_Server *p_server, <span class="keyword">const</span> UA_NodeId *, <span class="keywordtype">void</span> *, <span class="keyword">const</span> UA_NodeId *, <span class="keywordtype">void</span> *, <span class="keyword">const</span> UA_NodeId *,</div>
<div class="line">                 <span class="keywordtype">void</span> *, size_t, <span class="keyword">const</span> UA_Variant *inputs, size_t, UA_Variant *) -&gt; UA_StatusCode {</div>
<div class="line">    <a class="code hl_class" href="../../d0/d24/classrm_1_1ServerView.html">rm::ServerView</a> sv = p_server;</div>
<div class="line">    <span class="keyword">auto</span> num_node = nodeObjectsFolder | sv.<a class="code hl_function" href="../../d0/d24/classrm_1_1ServerView.html#a7f0ccea45af6a905fb9d033a693b0a73">find</a>(<span class="stringliteral">&quot;num&quot;</span>);</div>
<div class="line">    <span class="keywordtype">int</span> num = sv.<a class="code hl_function" href="../../d0/d24/classrm_1_1ServerView.html#af6f0c53c179713de3ab4342714daf58a">read</a>(num_node).<a class="code hl_function" href="../../df/db8/classrm_1_1Variable.html#a3c9c5cc7059a9da1067124d67c2accba">cast</a>&lt;<span class="keywordtype">int</span>&gt;();</div>
<div class="line">    <a class="code hl_class" href="../../df/db8/classrm_1_1Variable.html">rm::Variable</a> dst = *<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(inputs-&gt;data) + num;</div>
<div class="line">    sv.<a class="code hl_function" href="../../d0/d24/classrm_1_1ServerView.html#a259c4b69e74d86fe4bf50e21558d68b5">write</a>(num_node, dst);</div>
<div class="line">    <span class="keywordflow">return</span> UA_STATUSCODE_GOOD;</div>
<div class="line">};</div>
<div class="line">method.<a class="code hl_variable" href="../../d2/d23/structrm_1_1Method.html#a34efd80aa625fbe427cdeef38f043e57">iargs</a> = {{<span class="stringliteral">&quot;input&quot;</span>, UA_TYPES_INT32, 1, <span class="stringliteral">&quot;输入值&quot;</span>}};</div>
<div class="line">srv.addMethodNode(method);</div>
<div class="ttc" id="aclassrm_1_1ServerView_html"><div class="ttname"><a href="../../d0/d24/classrm_1_1ServerView.html">rm::ServerView</a></div><div class="ttdoc">OPC UA 服务器视图</div><div class="ttdef"><b>定义</b> server.hpp:48</div></div>
<div class="ttc" id="aclassrm_1_1ServerView_html_a259c4b69e74d86fe4bf50e21558d68b5"><div class="ttname"><a href="../../d0/d24/classrm_1_1ServerView.html#a259c4b69e74d86fe4bf50e21558d68b5">rm::ServerView::write</a></div><div class="ttdeci">bool write(const NodeId &amp;node, const Variable &amp;val) const</div><div class="ttdoc">给指定的变量节点写数据</div></div>
<div class="ttc" id="aclassrm_1_1ServerView_html_a7f0ccea45af6a905fb9d033a693b0a73"><div class="ttname"><a href="../../d0/d24/classrm_1_1ServerView.html#a7f0ccea45af6a905fb9d033a693b0a73">rm::ServerView::find</a></div><div class="ttdeci">FindNodeInServer find(std::string_view browse_name, uint16_t ns=1U) const</div><div class="ttdoc">获取路径搜索必要信息</div><div class="ttdef"><b>定义</b> server.hpp:79</div></div>
<div class="ttc" id="aclassrm_1_1ServerView_html_af6f0c53c179713de3ab4342714daf58a"><div class="ttname"><a href="../../d0/d24/classrm_1_1ServerView.html#af6f0c53c179713de3ab4342714daf58a">rm::ServerView::read</a></div><div class="ttdeci">Variable read(const NodeId &amp;node) const</div><div class="ttdoc">从指定的变量节点读数据</div></div>
<div class="ttc" id="aclassrm_1_1Variable_html_a3c9c5cc7059a9da1067124d67c2accba"><div class="ttname"><a href="../../df/db8/classrm_1_1Variable.html#a3c9c5cc7059a9da1067124d67c2accba">rm::Variable::cast</a></div><div class="ttdeci">static Tp cast(const rm::Variable &amp;val)</div><div class="ttdoc">将变量节点转化为指定类型的数据</div><div class="ttdef"><b>定义</b> variable.hpp:227</div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md270"></a>
5. 引用</h1>
<p><a class="el" href="../../d0/de3/citelist.html#CITEREF_ua-modeler">[3]</a> UaModeler · FreeOpcUa/opcua-modeler · Github </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../../doxygen.png" alt="doxygen"/>
</a> 1.12.0
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
